(re-find #"^[GCTA]"  "XCGFGGTDTTAA")
(re-seq #"^[GCTA]"  "XCGFGGTDTTAA")
  (and (re-find #"[A-Z]" request)
(re-seq #"^[GCTA]"  "XCGFGGTDTTAA")
(re-seq #"^[GCTA]" "XCGFGGTDTTAA")
(re-seq #"[GCTA]" "XCGFGGTDTTAA")
(re-seq #"[^GCTA]" "XCGFGGTDTTAA")
(empty? (re-seq #"[^GCTA]" "XCGFGGTDTTAA"))
(empty? (re-seq #"[^Z]" "XCGFGGTDTTAA"))
(re-seq #"[^Z]" "XCGFGGTDTTAA")
(re-seq #"[Z]" "XCGFGGTDTTAA")
(empty? (re-seq #"[Z]" "XCGFGGTDTTAA"))
(empty? (re-seq #"[G]" "XCGFGGTDTTAA"))
(present? (re-seq #"[G]" "XCGFGGTDTTAA"))
(not-empty? (re-seq #"[G]" "XCGFGGTDTTAA"))
(blank? (re-seq #"[G]" "XCGFGGTDTTAA"))
(nil? (re-seq #"[G]" "XCGFGGTDTTAA"))
(clojure.string/split "hello there" #" ")
(remove (fn [word] (empty? word) (clojure.string/split "hello there" #" "))
(remove (fn [word] (empty? word)) (clojure.string/split "hello there" #" "))
(remove (fn [word] (not (nil?( word)))) (clojure.string/split "hello there" #" "))
(remove (fn [word] (not (empty?( word)))) (clojure.string/split "hello there" #" "))
(remove (fn [word] (not (empty?(word))) (clojure.string/split "hello there" #" "))
(remove (fn [word] (empty? word)) (clojure.string/split "hello there" #" "))
